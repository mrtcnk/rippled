diff --git a/src/ed25519-donna/ed25519-donna-batchverify.h b/src/ed25519-donna/ed25519-donna-batchverify.h
index 43c4923b3e..67c1a8e294 100644
--- a/src/ed25519-donna/ed25519-donna-batchverify.h
+++ b/src/ed25519-donna/ed25519-donna-batchverify.h
@@ -105,7 +105,8 @@ heap_get_top2(batch_heap *heap, heap_index_t *max1, heap_index_t *max2, size_t l
 /* */
 static void
 ge25519_multi_scalarmult_vartime_final(ge25519 *r, ge25519 *point, bignum256modm scalar) {
-	const bignum256modm_element_t topbit = ((bignum256modm_element_t)1 << (bignum256modm_bits_per_limb - 1));
+
+    const bignum256modm_element_t topbit = ((bignum256modm_element_t)1 << (bignum256modm_bits_per_limb - 1));
 	size_t limb = limb128bits;
 	bignum256modm_element_t flag;
 
@@ -144,7 +145,11 @@ ge25519_multi_scalarmult_vartime_final(ge25519 *r, ge25519 *point, bignum256modm
 				break;
 			flag = topbit;
 		}
-	}
+
+
+    }
+
+
 }
 
 /* count must be >= 5 */
@@ -185,6 +190,7 @@ ge25519_multi_scalarmult_vartime(ge25519 *r, batch_heap *heap, size_t count) {
 	}
 
 	ge25519_multi_scalarmult_vartime_final(r, &heap->points[max1], heap->scalars[max1]);
+
 }
 
 /* not actually used for anything other than testing */
@@ -203,7 +209,80 @@ ge25519_is_neutral_vartime(const ge25519 *p) {
 
 int
 ED25519_FN(ed25519_sign_open_batch) (const unsigned char **m, size_t *mlen, const unsigned char **pk, const unsigned char **RS, size_t num, int *valid) {
-	batch_heap ALIGN(16) batch;
+    batch_heap ALIGN(16) batch;
+    ge25519 ALIGN(16) p;
+    bignum256modm *r_scalars;
+    size_t i, batchsize;
+    unsigned char hram[64];
+    int ret = 0;
+
+    for (i = 0; i < num; i++)
+        valid[i] = 1;
+
+    while (num > 3) {
+        batchsize = (num > max_batch_size) ? max_batch_size : num;
+
+        /* generate r (scalars[batchsize+1]..scalars[2*batchsize] */
+        ED25519_FN(ed25519_randombytes_unsafe) (batch.r, batchsize * 16);
+        r_scalars = &batch.scalars[batchsize + 1];
+        for (i = 0; i < batchsize; i++)
+            expand256_modm(r_scalars[i], batch.r[i], 16);
+
+        /* compute scalars[0] = ((r1s1 + r2s2 + ...)) */
+        for (i = 0; i < batchsize; i++) {
+            expand256_modm(batch.scalars[i], RS[i] + 32, 32);
+            mul256_modm(batch.scalars[i], batch.scalars[i], r_scalars[i]);
+        }
+        for (i = 1; i < batchsize; i++)
+            add256_modm(batch.scalars[0], batch.scalars[0], batch.scalars[i]);
+
+        /* compute scalars[1]..scalars[batchsize] as r[i]*H(R[i],A[i],m[i]) */
+        for (i = 0; i < batchsize; i++) {
+            ed25519_hram(hram, RS[i], pk[i], m[i], mlen[i]);
+            expand256_modm(batch.scalars[i+1], hram, 64);
+            mul256_modm(batch.scalars[i+1], batch.scalars[i+1], r_scalars[i]);
+        }
+
+        /* compute points */
+        batch.points[0] = ge25519_basepoint;
+        for (i = 0; i < batchsize; i++)
+            if (!ge25519_unpack_negative_vartime(&batch.points[i+1], pk[i]))
+                goto fallback;
+        for (i = 0; i < batchsize; i++)
+            if (!ge25519_unpack_negative_vartime(&batch.points[batchsize+i+1], RS[i]))
+                goto fallback;
+
+        ge25519_multi_scalarmult_vartime(&p, &batch, (batchsize * 2) + 1);
+        if (!ge25519_is_neutral_vartime(&p)) {
+            ret |= 2;
+
+            fallback:
+            for (i = 0; i < batchsize; i++) {
+                valid[i] = ED25519_FN(ed25519_sign_open) (m[i], mlen[i], pk[i], RS[i]) ? 0 : 1;
+                ret |= (valid[i] ^ 1);
+            }
+        }
+
+        m += batchsize;
+        mlen += batchsize;
+        pk += batchsize;
+        RS += batchsize;
+        num -= batchsize;
+        valid += batchsize;
+    }
+
+    for (i = 0; i < num; i++) {
+        valid[i] = ED25519_FN(ed25519_sign_open) (m[i], mlen[i], pk[i], RS[i]) ? 0 : 1;
+        ret |= (valid[i] ^ 1);
+    }
+
+    return ret;
+}
+
+int
+ED25519_FN(ed25519_sign_open_batch_cofactored) (const unsigned char **m, size_t *mlen, const unsigned char **pk, const unsigned char **RS, size_t num, int *valid) {
+
+    batch_heap ALIGN(16) batch;
 	ge25519 ALIGN(16) p;
 	bignum256modm *r_scalars;
 	size_t i, batchsize;
@@ -247,12 +326,27 @@ ED25519_FN(ed25519_sign_open_batch) (const unsigned char **m, size_t *mlen, cons
 				goto fallback;
 
 		ge25519_multi_scalarmult_vartime(&p, &batch, (batchsize * 2) + 1);
-		if (!ge25519_is_neutral_vartime(&p)) {
+
+        /* compute [8]p */
+        ge25519 p1, p2, p3;
+        ge25519_double(&p1,&p);
+        ge25519_double(&p2,&p1);
+        ge25519_double(&p3,&p2);
+
+        /* What about this?
+         * ge25519 p1;
+         * ge25519_double(&p1,&p);
+         * ge25519_double(&p,&p1);
+         * ge25519_double(&p1,&p);
+        */
+
+        if (!ge25519_is_neutral_vartime(&p3)) {
 			ret |= 2;
 
 			fallback:
 			for (i = 0; i < batchsize; i++) {
 				valid[i] = ED25519_FN(ed25519_sign_open) (m[i], mlen[i], pk[i], RS[i]) ? 0 : 1;
+
 				ret |= (valid[i] ^ 1);
 			}
 		}
diff --git a/src/ed25519-donna/ed25519.c b/src/ed25519-donna/ed25519.c
index 58a755b8d3..d26fe4f49a 100644
--- a/src/ed25519-donna/ed25519.c
+++ b/src/ed25519-donna/ed25519.c
@@ -19,10 +19,30 @@
 #include "ed25519-randombytes.h"
 #include "ed25519-hash.h"
 
+/*
+ * MC: Checks if it is identity or not
+ */
+unsigned char batch_point_buffer[3][32];
+
+static int
+ge25519_is_neutral_vartime2(const ge25519 *p) {
+    static const unsigned char zero[32] = {0};
+    unsigned char point_buffer[3][32];
+    curve25519_contract(point_buffer[0], p->x);
+    curve25519_contract(point_buffer[1], p->y);
+    curve25519_contract(point_buffer[2], p->z);
+    memcpy(batch_point_buffer[1], point_buffer[1], 32);
+    return (memcmp(point_buffer[0], zero, 32) == 0) && (memcmp(point_buffer[1], point_buffer[2], 32) == 0);
+}
+
 /*
 	Generates a (extsk[0..31]) and aExt (extsk[32..63])
 */
 
+
+
+
+
 DONNA_INLINE static void
 ed25519_extsk(hash_512bits extsk, const ed25519_secret_key sk) {
 	ed25519_hash(extsk, sk, 32);
@@ -89,9 +109,33 @@ ED25519_FN(ed25519_sign) (const unsigned char *m, size_t mlen, const ed25519_sec
 	/* S = (r + H(R,A,m)a) mod L */	
 	contract256_modm(RS + 32, S);
 }
-
 int
 ED25519_FN(ed25519_sign_open) (const unsigned char *m, size_t mlen, const ed25519_public_key pk, const ed25519_signature RS) {
+    ge25519 ALIGN(16) R, A;
+    hash_512bits hash;
+    bignum256modm hram, S;
+    unsigned char checkR[32];
+
+    if ((RS[63] & 224) || !ge25519_unpack_negative_vartime(&A, pk))
+        return -1;
+
+    /* hram = H(R,A,m) */
+    ed25519_hram(hash, RS, pk, m, mlen);
+    expand256_modm(hram, hash, 64);
+
+    /* S */
+    expand256_modm(S, RS + 32, 32);
+
+    /* SB - H(R,A,m)A */
+    ge25519_double_scalarmult_vartime(&R, &A, hram, S);
+    ge25519_pack(checkR, &R);
+
+    /* check that R = SB - H(R,A,m)A */
+    return ed25519_verify(RS, checkR, 32) ? 0 : -1;
+}
+
+int
+ED25519_FN(ed25519_sign_open_cofactored) (const unsigned char *m, size_t mlen, const ed25519_public_key pk, const ed25519_signature RS) {
 	ge25519 ALIGN(16) R, A;
 	hash_512bits hash;
 	bignum256modm hram, S;
@@ -109,14 +153,38 @@ ED25519_FN(ed25519_sign_open) (const unsigned char *m, size_t mlen, const ed2551
 
 	/* SB - H(R,A,m)A */
 	ge25519_double_scalarmult_vartime(&R, &A, hram, S);
-	ge25519_pack(checkR, &R);
 
-	/* check that R = SB - H(R,A,m)A */
-	return ed25519_verify(RS, checkR, 32) ? 0 : -1;
+    ge25519_pack(checkR, &R);
+
+    ge25519_unpack_negative_vartime(&R, checkR);
+
+    unsigned char Rprime[32];
+    for (int i = 0; i < 32; i++) {
+        Rprime[i] = RS[i];
+    }
+    ge25519 Rprimepoint;
+    ge25519_unpack_negative_vartime(&Rprimepoint, Rprime);
+    ge25519 Rprimepointneg;
+
+    curve25519_neg(Rprimepointneg.x, Rprimepoint.x);
+    curve25519_copy(Rprimepointneg.y, Rprimepoint.y);
+    curve25519_neg(Rprimepointneg.t, Rprimepoint.t);
+    curve25519_copy(Rprimepointneg.z, Rprimepoint.z);
+
+    ge25519 result, result1, result2, result3;
+    // result = R - sB - H(R,A,m)A
+    ge25519_add(&result,&R,&Rprimepointneg);
+
+    ge25519_double(&result1,&result);
+    ge25519_double(&result2,&result1);
+    ge25519_double(&result3,&result2);
+
+    return ge25519_is_neutral_vartime2(&result3) ? 0 : -1;
+
 }
 
-#include "ed25519-donna-batchverify.h"
 
+#include "ed25519-donna-batchverify.h"
 /*
 	Fast Curve25519 basepoint scalar multiplication
 */
diff --git a/src/ed25519-donna/ed25519.h b/src/ed25519-donna/ed25519.h
index dc86675cd1..7f3209f7d4 100644
--- a/src/ed25519-donna/ed25519.h
+++ b/src/ed25519-donna/ed25519.h
@@ -15,6 +15,12 @@ typedef unsigned char curved25519_key[32];
 
 void ed25519_publickey(const ed25519_secret_key sk, ed25519_public_key pk);
 int ed25519_sign_open(const unsigned char *m, size_t mlen, const ed25519_public_key pk, const ed25519_signature RS);
+
+
+int ed25519_sign_open_cofactored(const unsigned char *m, size_t mlen, const ed25519_public_key pk, const ed25519_signature RS);
+int ed25519_sign_open_batch_cofactored(const unsigned char **m, size_t *mlen, const unsigned char **pk, const unsigned char **RS, size_t num, int *valid);
+
+
 void ed25519_sign(const unsigned char *m, size_t mlen, const ed25519_secret_key sk, const ed25519_public_key pk, ed25519_signature RS);
 
 int ed25519_sign_open_batch(const unsigned char **m, size_t *mlen, const unsigned char **pk, const unsigned char **RS, size_t num, int *valid);
